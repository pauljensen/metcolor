

`%>%` <- magrittr::`%>%`
`%<>%` <- magrittr::`%<>%`


load_svg <- function(file, ns_strip=TRUE) {
  svg <- xml2::read_xml(file)
  if (ns_strip)
    svg %<>% xml2::xml_ns_strip()
  return(svg)
}

remove_svg_ns <- function(svg) {
  xml2::xml_ns_strip(svg)
}

add_svg_ns <- function(svg) {
  top <- xml2::xml_find_first(svg, ".")
  xml2::xml_attr(top, "xmlns") <- "http://www.w3.org/2000/svg"
  invisible(svg)
}

apply_color_map <- function(data,
                            colors=RColorBrewer::brewer.pal(9, "YlGn"),
                            normalize="all",
                            colorNA="lightgrey") {

  # avoid issues with matrix conversion and apply when data has only one row
  if (is.data.frame(data) && nrow(data) == 1)
    data <- rbind(data, data)

  maxNA <- function(...) max(..., na.rm=TRUE)
  minNA <- function(...) min(..., na.rm=TRUE)
  scale01 <- function(x) (x - minNA(x)) / (maxNA(x) - minNA(x))
  if (normalize == "all") {
    data <- scale01(data)
  } else if (normalize == "row") {
    data <- t(apply(data, 1, scale01))
  } else if (grepl("col", normalize)) {
    data <- apply(data, 2, scale01)
  } else {
    stop("Normalize must be 'all', 'row', or 'column'.")
  }

  ramp <- colorRamp(colors)
  scalefun <- function(x) rgb(ramp(x), maxColorValue = 255)
  colorNA <- rgb(t(col2rgb("lightgrey")), maxColorValue = 255)

  data0 <- data
  data0[is.na(data)] <- 0
  hex <- as.matrix(apply(data0, 2, scalefun))
  hex[is.na(data)] <- colorNA
  dimnames(hex) <- dimnames(data)

  return(list(data=hex, colorNA=colorNA))
}

get_rxn_name <- function(id) {
  stringr::str_match(id, "\\$([^:]*)::")[ ,2]
}

get_met_name <- function(id) {
  stringr::str_match(id, "([^:#]*)(#\\d+)?::")[ ,2]
}

get_default <- function(x, name, default=NA) {
  if (name %in% names(x))
    x[name]
  else
    default
}

apply_colors <- function(svg, values, default, features=c("nodes", "edges")) {
  edge_groups <- svg %>%
    xml2::xml_find_all("g[@class='graph']") %>%
    xml2::xml_find_all("g[@class='edge']")

  node_groups <- svg %>%
    xml2::xml_find_all("g[@class='graph']") %>%
    xml2::xml_find_all("g[@class='node']")

  set_edge_color <- function(g) {
    name <- get_rxn_name(xml2::xml_attr(g, "id"))

    to_color <- g %>% xml2::xml_find_all("path|polygon")
    xml2::xml_attr(to_color, "stroke") <- get_default(values, name, default)

    to_color <- g %>% xml2::xml_find_all("polygon")
    xml2::xml_attr(to_color, "fill") <- get_default(values, name, default)
  }

  set_node_color <- function(n) {
    name <- get_met_name(xml2::xml_find_first(n, "title/text()"))

    to_color <- n %>% xml2::xml_find_all("ellipse")
    xml2::xml_attr(to_color, "stroke") <- get_default(values, name, default)
    xml2::xml_attr(to_color, "fill") <- get_default(values, name, default)
  }

  if ("edges" %in% features)
    lapply(edge_groups, set_edge_color)
  if ("nodes" %in% features)
    lapply(node_groups, set_node_color)

  return(NULL)
}

assert_ending <- function(s, ending) {
  if (!stringr::str_detect(s, paste0(ending, "$")))
    paste0(s, ending)
  else
    s
}

run_metcolor <- function(svg, data, path=".", quiet=FALSE, features=c("nodes", "edges"), write=TRUE, ...) {
  if (is.character(svg))
    svg %<>% load_svg()

  mapped <- apply_color_map(data, ...)
  data <- mapped$data
  default <- mapped$colorNA

  path %<>% assert_ending("/")
  files <- paste0(path, dimnames(data)[[2]], ".svg")
  for (i in 1:ncol(data)) {
    x <- data[ ,i]
    names(x) <- dimnames(data)[[1]]

    apply_colors(svg, x, default, features=features)
    if (write) {
      add_svg_ns(svg)
      if (!quiet)
        cat(paste0("Finished file ", files[i], ".\n"))
      xml2::write_xml(svg, files[i])
      remove_svg_ns(svg)
    }
  }

  invisible(svg)
}

#' Color a metabolic map.
#'
#' @param svg SVG image file of the metabolic network, generated by MetDraw.
#' @param rxns Data frame with row names matching reaction names in the metabolic model.
#' One colored map will be produced for each column of data, using the column names to create
#' file names. If \code{NULL}, reactions colors are left to the color on the original map.
#' @param mets Same as \code{rxns}, but for metabolites.
#' @param path Location for the output files.
#' @param quiet If \code{FALSE}, print updates as each file is processed.
#' @param write If \code{TRUE} (default), write other files. Otherwise, only update the SVG object.
#' @param colors Color pallette (list of color names).
#' @param normalize Normalization applied before mapping to colors. \code{"all"} applies colors to
#' span the entire range of the dataset (all rows, all colors). \code{"row"} or \code{"column"} normalizes
#' each row or column independently.
#' @param colorNA Color used for NAs in \code{data} or for reactions missing from \code{data}.
#'
#' @return Returns the SVG XML object (invisibly).
#'
#' @export
metcolor <- function(svg, rxns=NULL, mets=NULL, ...) {
  if (!is.null(rxns) && !is.null(mets)) {
    # chain both operations
    svg %<>% run_metcolor(data=rxns, features="edges", write=FALSE, ...) %>%
      run_metcolor(data=mets, features="nodes", ...)
  } else if (!is.null(rxns)) {
    svg %<>% run_metcolor(data=rxns, features="edges", ...)
  } else if (!is.null(mets)) {
    svg %<>% run_metcolor(data=mets, features="nodes", ...)
  }

  invisible(svg)
}


